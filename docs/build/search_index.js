var documenterSearchIndex = {"docs":
[{"location":"index.html#TestContexts","page":"TestContexts","title":"TestContexts","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"TestContexts.TestContexts","category":"page"},{"location":"index.html#TestContexts.TestContexts","page":"TestContexts","title":"TestContexts.TestContexts","text":"Run multiple tests in a controlled context.\n\nThis provides the following features which are missing from the default @testset macro:\n\nTest cases are logged using @debug, to make it easier to debug and trace test execution.\nTest cases can be filtered using regular expression patterns, to allow debugging specific test cases.\nEach test case starts with a controlled environment whose content is independent from the other test cases. This environment can be created incrementally by nesting test sets, allowing setup/teardown steps to be reused for multiple test cases.\n\n\n\n\n\n","category":"module"},{"location":"index.html#The-global-test-context","page":"TestContexts","title":"The global test context","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"The global tc object is used to configure and access the tests context.","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"TestContexts.tc","category":"page"},{"location":"index.html#TestContexts.tc","page":"TestContexts","title":"TestContexts.tc","text":"The global context for running tests. This is mainly used to access the test environment; by accessing tc.foo one obtains the value of some foo property which was previously set up by a test_set or by the test_case itself.\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Setting-up-the-test-environment","page":"TestContexts","title":"Setting up the test environment","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"For the common case when multiple test cases require the same initial data, one can invoke test_set. This works similarly to a \"given\" or \"when\" clause in BDD. The data is stored inside the global tc context.","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"TestContexts.PropertyValue\nTestContexts.SharedValue\nTestContexts.PrivateValue\nTestContexts.test_set","category":"page"},{"location":"index.html#TestContexts.PropertyValue","page":"TestContexts","title":"TestContexts.PropertyValue","text":"Possible values for a test property.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TestContexts.SharedValue","page":"TestContexts","title":"TestContexts.SharedValue","text":"SharedValue(value::Any)\n\nA shared value will be used as-is by all tests. If the value is mutable, the test cases are responsible to never change it (or at least ensure the original value is restored by the end of each test).\n\n\n\n\n\n","category":"type"},{"location":"index.html#TestContexts.PrivateValue","page":"TestContexts","title":"TestContexts.PrivateValue","text":"PrivateValue(make::Function, finalize::Union{Function,Nothing}=nothing)\n\nA private value will be (lazily) re-created for each test (that accesses it) by invoking the make function. This value can be mutated at will by the test case without affecting any other test case. If the finalize function was specified, it is invoked at the end of each test case (that accessed the value) and is given the value so it can be properly disposed of.\n\n\n\n\n\n","category":"type"},{"location":"index.html#TestContexts.test_set","page":"TestContexts","title":"TestContexts.test_set","text":"test_set(body::Function, name::String, data...)\n\nSimilar to @testset but uses the global tc test context for running tests under the given name. The optional data must a series of zero or more entries, each in the format property => value where property is a symbol and value is a PropertyValue.\n\nNesting test sets is allowed. This is a common pattern for incrementally setting up a test environment for the actual test cases. In BDD terminology, a test set is similar to the \"given\" or \"when\" clauses.\n\nThe property values are not accessible (yet). See test_case for actually accessing the data.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Running-tests","page":"TestContexts","title":"Running tests","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"To actually run tests, invoke test_case (typically nested within one or more test_set calls). Each test case will be logged using @debug before it starts execution.","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"TestContexts.test_case","category":"page"},{"location":"index.html#TestContexts.test_case","page":"TestContexts","title":"TestContexts.test_case","text":"test_case(body::Function, name::String, data...)\n\nSimilar to test_set but is used to wrap actual @test code. Allows access to any data previously setup by the containing test_set calls, if any, or in the test_case call itself. The properties data is available during the test by accessing tc.property. A separate instance is created (lazily) for any private data for each test case. If a finalize function was specified, it is invoked to properly dispose of the data at the end of the test case.\n\nNesting a test set or a test case inside a test case is forbidden. That is, a test case is expected to actually test some specific scenario which was set up by the containing test sets. In BDD terminology, a test case is similar to the \"then\" clause.\n\nIf any test_patterns were specified, and the full test_name does not match any of these patterns, then the test case is silently ignored. Otherwise, the test name is logged using @debug before the test case code is executed.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Controlling-test-execution","page":"TestContexts","title":"Controlling test execution","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"Invoking test_patterns allows specifying a list of patterns of full test names. If this list is not empty, only tests which match at least one of the patterns will actually execute:","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"TestContexts.test_name\nTestContexts.test_patterns","category":"page"},{"location":"index.html#TestContexts.test_name","page":"TestContexts","title":"TestContexts.test_name","text":"test_name()::AbstractString\n\nReturn the full name of the current test context. This is a /-separated path containing the names of all the nested test_set and test_case calls. This full name is automatically logged using @debug at the start of each test case. It is also matched against any test_patterns to allow executing only a specific subset of the tests.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TestContexts.test_patterns","page":"TestContexts","title":"TestContexts.test_patterns","text":"test_patterns(patterns::Vector{Union{String,Regex}})::Nothing\n\nSpecify patterns for the tests to run. Only tests whose full test_name matches one of the patterns will be run. If the vector is empty, all tests will be run.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Example","page":"TestContexts","title":"Example","text":"","category":"section"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"In the following example, we have two test cases, db/filled and db/empty. Each of these test cases starts with a fresh copy of the database, which is deleted when the test case is done.","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"test_set(\"db\", :db => PrivateValue(create_db_on_disk, remove_db_from_disk)) do\n    test_case(\"filled\") do\n        fill_db(tc.db)\n        @test !isempty(query_db(tc.db))\n    end\n    test_case(\"empty\") do\n        @test isempty(query_db(tc.db))\n    end\nend","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"If we first invoke:","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"test_patterns(['.*/filled'])","category":"page"},{"location":"index.html","page":"TestContexts","title":"TestContexts","text":"Then running the tests will only execute the db/filled test case. A common usage is to add test_patterns(Base.ARGS) early in runtests.jl, which allows specifying which tests to run on the command line.","category":"page"}]
}
